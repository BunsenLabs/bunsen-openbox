#!/bin/sh
# prerem script for bunsen-openbox

#Summary of ways this script can be called:
#    prerm remove
#    old-prerm upgrade new-version
#    new-prerm failed-upgrade old-version
#    conflictor's-prerm remove in-favour package new-version
#    deconfigured's-prerm deconfigure in-favour package-being-installed version removing conflicting-package version

set -e

this_package=$DPKG_MAINTSCRIPT_PACKAGE

# file suffixes
ours=.bunsen
theirs=.bunsen-orig

# the package whose behaviour this package is modifying
file_package=openbox

# one file per line: files in /usr/lib whose path depends on system architecture
# (path after multiarch tuple)
# It is assumed that no such filepaths contain linebreaks.
libfiles='openbox-autostart'

unlink() {
    local file ourfile theirfile
    file="$1"
    ourfile=${file}${ours}
    theirfile=${file}${theirs}
    [ -L "$file" ] || {
        echo "$file is not a symlink"
        return
    }
    if [ "$(readlink "$file")" = "$(basename "$ourfile")" ]
    then
        rm -f "$file"
    else
        echo "$file is not linked to $(basename "$ourfile")"
    fi
}

undisplace() {
    local file diverted_file diverter
    file="$1"
    [ -e "$file" ] && {
        echo "File $file exists"
        return
    }
    diverted_file="$(dpkg-divert --truename "$file")"
    diverter="$(dpkg-divert --listpackage "$file")"
    case "$diverter" in
    "$this_package")
        dpkg-divert --remove --rename --package "$this_package" "$file"
        ;;
    '')
        echo "$file is not diverted."
        ;;
    *)
        echo "$file is diverted to $diverted_file by $diverter" >&2
        exit 1
        ;;
    esac
}

rm_ourfile() {
    local ourfile=${1}${ours}
    if [ -f "$ourfile" ]
    then
        rm "$ourfile"
    else
        echo "$ourfile does not exist"
    fi
}

# get full path from post-tuple section
get_libpath() {
    local libfile libpath
    libfile=$1
    libpath=$(dpkg -L "$file_package" | grep "^/usr/lib/[^/]\+/${libfile}\$") || {
        echo "$libfile not listed under /usr/lib by $file_package" >&2
        exit 1
    }
    [ -f "$libpath" ] || {
        echo "$libpath is not a file" >&2
        exit 1
    }
    printf '%s' "$libpath"
}

case "$1" in
    remove|deconfigure)
        while read -r libfile
        do
            filepath=$(get_libpath "$libfile")
            unlink "$filepath"
            undisplace "$filepath"
            rm_ourfile "$filepath"
        done <<EOF
$libfiles
EOF
    ;;

    upgrade|failed-upgrade)
    ;;

    *)
        echo "prerm called with unknown argument '$1'" >&2
        exit 1
    ;;
esac

# dh_installdeb will replace this with shell code automatically
# generated by other debhelper scripts.

#DEBHELPER#
